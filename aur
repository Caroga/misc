#!/usr/bin/env bash

## config
[[ -e "$HOME/.config/aur.rc" ]] && {
	source "$HOME/.config/aur.rc"
}

cfg_work_dir="${cfg_work_dir:-$HOME/.aur}"
cfg_aur_url="${cfg_aur_url:-https://aur.archlinux.org}"
cfg_abs_tree="${cfg_abs_tree:-/var/abs}"
cfg_makepkg_flags='-rs'
cfg_libfbt_path="${cfg_libfbt_path:-/usr/lib/libfbt}"
# /config

[[ -e "$cfg_libfbt_path" ]] || {
	echo "This script depends on libfbt: https://github.com/fbt/libfbt"
	exit 1
}

source "${cfg_libfbt_path}/libfbt.sh"

aur.usage() {
	echo "$0 [options] [packages]"

	echo "SYNC (-S):"
	echo "-s	# search"
	echo "-d	# download only"
	echo
	echo "OTHER:"
	echo "-h	# show this message"
}

aur.args() {
	while [[ "$1" ]]; do
		case "$1" in
			-a) flag_aur_only='1';;
			-S) action_group='sync';;
			-s) action='search';;
			-u) flag_update='1';;
			-y)
				lf.msg "Updating ABS..."
				sudo abs &>/dev/null || {
					lf.err 'Failed!'
					return 1
				}
			;;

			-w) flag_download_only='1';;
			-b) flag_build='1';;
			-h) aur.usage; exit;;
			--) :;;
			*) args+=( "$1" );;
		esac
		shift
	done
}

aur.get_package() {
#	local package_repo
	[[ "$flag_aur_only" ]] && {
		package_repo="`package-query --aur-url "$cfg_aur_url" -A "$1" | head -1 | cut -d '/' -f1`"
	} || {
		package_repo="`package-query --aur-url "$cfg_aur_url" -AS "$1" | head -1 | cut -d '/' -f1`"
	}

	[[ "$package_repo" ]] || {
		lf.err "Package $1 not found!"
		return 1
	}

	cd "$cfg_work_dir"

	case "${package_repo}" in
		aur)	
			lf.msg "Downloading $cfg_aur_url/packages/${1:0:2}/${1}/${1}.tar.gz"
			curl "$cfg_aur_url/packages/${1:0:2}/${1}/${1}.tar.gz" | gzip -d | tar xf - || {
				lf.err "Fail!"
				return 3
			}
		;;

		*)
			[[ "$flag_build" ]] && {
				cp -r "${cfg_abs_tree}/${package_repo}/${1}" . || {
					lf.err "Fail!"
					return 9
				}
			} || {
				[[ "$flag_download_only" ]] && {
					sudo pacman --cachedir "`pwd`" -Sw "$1"
				}
			}
		;;
	esac

	return 0
}

aur.update() {
	local old_pkgs
	old_pkgs=( `package-query -Au | cut -d ' ' -f1` )

	[[ "$flag_aur_only" ]] || { sudo pacman -Suy; }

	lf.msg "Updating packages from AUR..."

	[[ "$old_pkgs" ]] || {
		lf.msg "Everything seems to be up to date."
		return 0
	}

	read -n1p "[$0] Packages that need updates: ${old_pkgs[@]}. Proceed? [Y/n] " answer
	[[ "$answer" != 'y' ]] || {
		lf.msg 'Ok.'
		return 1
	}

	for i in "${old_pkgs[@]}"; do
		"$BASH" "$0" -S "$i"
	done
}

aur.build_package() {
	cd "$cfg_work_dir/$package"
	[[ "$flag_build" ]] || { cfg_makepkg_flags+=' -i'; }
	makepkg ${cfg_makepkg_flags}
}

aur.search() {
	[[ "$flag_aur_only" ]] && {
		package-query --aur-url "$cfg_aur_url" -As "$1"
	} || {
		package-query --aur-url "$cfg_aur_url" -ASs "$1"
	}
}

aur.init() {
	for i in "$cfg_work_dir"; do
		[[ -e "$i" ]] || {
			mkdir -p "$i" || {
				lf.msg "Cannot create $i!"
				return 1
			}
		}
	done
}

aur.main() {
	aur.init || { return 1; }
	aur.args `lf.getopt "$@"` || { return 1; }

	package="${args[0]##*/}"

	case "$action_group" in
		sync)
			action="${action:-build}"

			[[ "$flag_update" ]] && {
				aur.update
			}

			[[ "$package" ]] && {
				case "$action" in
					search) aur.search "$package" || { return "$?"; };;
					build)
						aur.get_package "$package" || { return "$?"; }

						[[ "$flag_download_only" ]] || {
							case "$package_repo" in	
								aur)
									aur.build_package || { return "$?"; }
								;;

								*)
									[[ "$flag_build" ]] && {
										aur.build_package || { return "$?"; }
									} || {
										sudo pacman -S "$package"
									}
								;;
							esac
						}
					;;
				esac
			}
		;;

		*) sudo pacman "$@";;
	esac
}

aur.main "$@"
